<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[垃圾收集器与内存分配策略]]></title>
      <url>http://yoursite.com/2016/07/29/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h3 id="判定一个对象是否已经死亡的方法"><a href="#判定一个对象是否已经死亡的方法" class="headerlink" title="判定一个对象是否已经死亡的方法"></a>判定一个对象是否已经死亡的方法</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>该方法是为每个对象添加一个引用计数器，每当有一个地方引用了该对象的时候，该计数器的值加1；当引用失效时，计数器的值减1。当计数器的值为0的时候就回收该对象。但其主要的问题在于其无法解决循环引用的问题。如代码所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">    <span class="comment">//设ReferenceGc是一个类，其包含属性instance同样也是一个RefenenceGc对象</span></div><div class="line">	ReferenceGc objA=<span class="keyword">new</span> ReferenceGc();</div><div class="line">	ReferenceGc objB=<span class="keyword">new</span> ReferenceGc();</div><div class="line">	objA.instance=objB;</div><div class="line">	objB.instance=objA;</div><div class="line">	objA=<span class="keyword">null</span>;</div><div class="line">	objB=<span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述的代码就会出现循环引用的问题，我们会发现计数器永远都不会变为0。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>该算法基本思路是通过一系列被称为“GC Roots”的对象作为根节点（起始点），从这些节点开始向下搜索，搜索过程中所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的（即GC Roots到这个对象不可达）时候，即认为该对象是可回收对象。</p>
<ul>
<li>虚拟机栈中的引用的对象。</li>
<li>方法区中类静态属性引用指向的对象。</li>
<li>方法区中常量引用指向的对象。</li>
<li>Native方法中JNI（一般指的是native方法）引用的对象。</li>
</ul>
<h4 id="何为引用以及引用的分类"><a href="#何为引用以及引用的分类" class="headerlink" title="何为引用以及引用的分类"></a>何为引用以及引用的分类</h4><p>首先我们知道判断一个对象是否存活都与该对象对应的引用相关。在传统的定义中：如果引用类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该这块内存代表着一个引用。但是传统的引用定义太过狭隘，其定义限制了对象只有两种状态“被引用”或者“没有被引用”。但是对于一些“食之无味，弃之可惜”的独享就显得无能为力了（即一个中间状态）。即我们希望描述这样一类对象：当内存足够的时候，将其保留在内存中，反之如果在垃圾手机后内存还是非常紧张，则可以抛弃这些对象。故在java虚拟机对引用进行概念上的补充，将引用分为了“强引用”、“软引用”、“弱引用”、“虚引用”。具体定义如下：</p>
<ul>
<li>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。  ps：强引用其实也就是我们平时A a = new A()这个意思。</li>
<li>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果进行垃圾回收后发现内存空间不足了，就会回收这些对象的内存，同时如果回收了该对象之后发现内存空间还是不够就会抛出OutOfMemoryError错误，只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存（下文给出示例）。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</li>
<li>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。（其强度比软引用更弱一点，被弱引用关联的对象只能生存到下一次垃圾回收发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象）(WeakReference)</li>
<li>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。为一个对象设置虚引用关联的唯一目的在于能在对象被垃圾回收的时候收到一个系统通知。（PhantomReference）</li>
</ul>
<h4 id="对象死亡与否"><a href="#对象死亡与否" class="headerlink" title="对象死亡与否"></a>对象死亡与否</h4><p>其实通过引用计数法或者可达性分析判定了一个对象没有了任何引用存在，此时对象也只是处于“缓刑期”，即其还是有可能在复活的。要真正宣告一个对象死亡至少需要两个标记过程：第一次是通过可达性分析对象是否可达，并且进行一次筛选，筛选的条件是对象有无必要执行finalize()方法。当对象没有覆盖该方法或者该方法已经被调用过一次，这些情况都会被判定为没有必要执行。但如果判定为有必要执行，则会将该对象放置在F-Queue的队列中，并在稍后通过一个JVM的优先级很低的Finalizer线程去执行它。finalize方法是对象逃脱死亡的最后一次机会，稍后GC将对F-Queue中对象进行第二次标记，如果对象在finalize中成功解救自己（即有关联了某个引用），则会被移除队列。但我们要知道的是finalize方法只能被执行一次，所以对象也只有一次解救自己的机会。</p>
<h4 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h4><p>永久代的垃圾回收主要指两部分的内容：废弃常量和无用的类。常量的回收方法和方式和一般java堆中垃圾回收方式相似。但类的回收则比较苛刻，判定一个类是否是“无用的类”需要经过三个步骤：</p>
<ul>
<li>该类的实例是否已经都被回收</li>
<li>加载该类的ClassLoader是否已经回收</li>
<li>该类所对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JAVA对象的创建和内存存储布局]]></title>
      <url>http://yoursite.com/2016/07/29/JAVA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<h3 id="JAVA对象的创建"><a href="#JAVA对象的创建" class="headerlink" title="JAVA对象的创建"></a>JAVA对象的创建</h3><p>&emsp;&emsp;对象的创建一共分三步进行。</p>
<h4 id="1-、为对象分配内存"><a href="#1-、为对象分配内存" class="headerlink" title="(1)、为对象分配内存"></a>(1)、为对象分配内存</h4><p>&emsp;&emsp;这里所得创建对象（仅限于普通对象，不包含数组和Class对象等），通常我们通过一个new关键字创建对象。但我们要知道虚拟机在遇到一条new指令时，其首先将去检查这个指令参数（类名）是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载（将符号引用转变成直接引用，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）、解析和初始化过。如果没有，那必须先执行相应的类加载过程。<br>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。一个对象所需内存的大小在类加载完成后便可完全确定，而一般对象分配内存的方式有两种：</p>
<ol>
<li>指针碰撞：这是假设堆中内存总是工整的，所有使用过的内存放在一般、未使用的放在另一边，这样用一个指针作为分界点的指示器，那分配内存的时候就只需要该指针移动相应对象大小的距离就可以了。（这有点类似于JAVA内存回收中的标记-清除-整理算法后的内存状态）</li>
<li>空闲列表：但如果JAVA堆并不是规整的时候，就无法采用上述的方式，此时虚拟机就需要维护一个列表，记录哪些内存块是可用的，而在分配的时候在列表中寻找到一块足够大的空间划分给该对象实例，并且更新该列表上的记录，这种方式被称为“空闲列表”。（CMS垃圾收集器由于采用标记-清除的算法就容易导致内存碎片化，此时只能采用该方式为对象分配内存）。</li>
</ol>
<p>&emsp;&emsp;所以说采用什么样的对象内存分配方式，本质上和该块内存使用什么样的垃圾收集器是密切相关的。<br>&emsp;&emsp;在内存分配中还需要考虑的一个问题如何保证内存分配的线程安全，即你可能出现正在给对象A分配内存，指针还未来得及修改，，对象B又同时使用了原来的指针分配内存的情况。解决这种并发问题（由于创建对象在jvm中是很频繁的问题）有两种方案：</p>
<ol>
<li>一种是对分配内存空间的动作进行同步处理-实际上虚拟机采用CAS配上失败重试的方式保证指针更新操作的原子性</li>
<li>另一种是将内存分配的动作按照线程划分在不同的空间中进行，即为每个线程在JAVA堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB）。哪个线程需要分配堆内存，就在对象的那个线程的TLAB上分配，只有TLAB用完分配新的TLAB得时候才需要用到同步锁定。虚拟机是否使用TLAB通过-XX:+/-UseTLAB参数设定。</li>
</ol>
<p>&emsp;&emsp;内存分配完成后，虚拟机需要为分配到内存空间初始化为零值（这里是指的是一些实例数据）。</p>
<h4 id="2-、虚拟机对对象进行必要的设置-对象头的设置"><a href="#2-、虚拟机对对象进行必要的设置-对象头的设置" class="headerlink" title="(2)、虚拟机对对象进行必要的设置-对象头的设置"></a>(2)、虚拟机对对象进行必要的设置-对象头的设置</h4><p>&emsp;&emsp;虚拟机接下来会对该对象进行必要的设置，如该对象是哪个类的实例、如何找到类的元数据信息、对象的HASH码、对象的GC分代年龄等。这些信息都放在对象的对象头中。根据虚拟机当前的运行状态的不同，对象头会有不同的设置。</p>
<h4 id="3-、对象的初始化"><a href="#3-、对象的初始化" class="headerlink" title="(3)、对象的初始化"></a>(3)、对象的初始化</h4><p>&emsp;&emsp;对虚拟机而言，一个新的对象已经产生了，但对JAVA线程而言，对象的创建才刚刚开始，这是因为对象的初始化方法还没有执行（初始化代码块、构造函数等），此时所有的字段均为0，所以new指令之后会接着执行init方法，实现对对象的初始化。</p>
<h3 id="对象在内存中存储方式-内存中的存储布局"><a href="#对象在内存中存储方式-内存中的存储布局" class="headerlink" title="对象在内存中存储方式-内存中的存储布局"></a>对象在内存中存储方式-内存中的存储布局</h3><p>&emsp;&emsp;这一节主要说明一个对象在内存中是由哪几部分组成。一个对象在内存中存储布局可以分为三个区域：对象头、实例数据、对齐填充。<br>&emsp;&emsp;所谓对齐补充的存在不是必然的，也没有特殊的含义，仅仅起着占位符的作用，这是因为Hotspot的VM的自动内存管理系统要求对象的其实地址必须是8字节的整数倍，也即是说独享的大小必须是8字节的整数倍。而对象头正好是8字节的整数倍，而如果对象实例部分没有对齐的时候，就需要通过对齐填充来补全。</p>
<h3 id="对象的访问方式"><a href="#对象的访问方式" class="headerlink" title="对象的访问方式"></a>对象的访问方式</h3><p>&emsp;&emsp;一般来说，我们是通过reference数据来操作堆上的具体对象，但并没有定义这个引用通过何种方式去定位、方位堆中对象的具体位置，所以对象的访问方式也是取决于虚拟机的实现而定的。<br>一个Java的引用访问涉及到3个内存区域：JVM栈，堆，方法区。以最简单的本地变量引用：Object obj = new Object()为例：</p>
<ul>
<li>Object obj表示一个本地引用，存储在JVM栈的本地变量表中，表示一个reference类型数据；</li>
<li>new Object()作为实例对象数据存储在堆中；</li>
<li>堆中还记录了Object类的类型信息（接口、方法、field、对象类型等）的地址，这些地址所执行的数据存储在方法区中；</li>
</ul>
<p>&emsp;&emsp;目前主流的对象访问方式有两种：</p>
<ul>
<li>通过句柄访问：JAVA堆中会划分出一块内存来作为句柄池，reference中存放的是对象句柄的地址，而句柄中则包含了对象实例数据和类型数据的各自的具体地址信息。如图所示：<br><img src="https://github.com/xhwhutbupt/xhwhutbupt.github.io/blob/master/images/interview_method1.png" width="350" height="250" alt="图片名称" align="center"></li>
<li>使用直接指针访问：采用该方式JAVA堆对象就需要考虑如何放置访问类型数据的相关信息如图所示：<br><img src="https://github.com/xhwhutbupt/xhwhutbupt.github.io/blob/master/images/interview_method2.png" width="350" height="250" alt="图片名称" align="center"></li>
</ul>
<p>&emsp;&emsp;使用句柄池的好处是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集的时候移动对象）时只会改变句柄中的实例数据指针，而reference本身无需改变。使用直接指针的函数就是速度更快，节省了一次指针定位的开销，由于对象的访问在JAVA中非常频繁，所以这种开销还是很可观的。在hotspot vm中使用的是方法2。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JAVA内存区域与内存溢出异常]]></title>
      <url>http://yoursite.com/2016/07/26/JAVA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
      <content type="html"><![CDATA[<h2 id="JAVA内存区域-JAVA虚拟机运行时数据区"><a href="#JAVA内存区域-JAVA虚拟机运行时数据区" class="headerlink" title="JAVA内存区域-JAVA虚拟机运行时数据区"></a>JAVA内存区域-JAVA虚拟机运行时数据区</h2><p>&emsp;&emsp;了解Java GC机制，必须先清楚在JVM中内存区域的划分。在Java运行时的数据区里，由JVM管理的内存区域分为下图几个模块：<br><img src="xhwhutbupt.github.io/images/store.jpg" width="350" height="250" alt="图片名称" align="center"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>&emsp;&emsp;其实线程私有的，用于指定当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取吓一跳需要执行的字节码指令。如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，这是计数值则为空。该内存区域时唯一一个java虚拟机规范中没有规定outofmemoryerror的区域</p>
<h3 id="JAVA虚拟机栈"><a href="#JAVA虚拟机栈" class="headerlink" title="JAVA虚拟机栈"></a>JAVA虚拟机栈</h3><p>&emsp;&emsp;该区域同样是线程私有的，其生命周期和线程相同。一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。<br>&emsp;&emsp;局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。在局部变量表中，只有long和double类型会占 用2个局部变量空间（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。需要注意的是，局部变量表是在编译时就已经确定 好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。<br>&emsp;&emsp;虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StatckOverFlowError（栈溢出）；不过多 数Java虚拟机都允许动态扩展虚拟机栈的大小(有少部分是固定长度的)，所以线程可以一直申请栈，知道内存不足，此时，会抛出OutOfMemoryError（内存溢出）。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>&emsp;&emsp;本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同，唯一的区别是：虚拟机栈是执行Java方法的，而本地方法栈是用来执行native方法的，在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将本地方法栈与虚拟机栈放在一起使用。同样其会抛出两种异常分别是StatckOverFlowError和OutOfMemoryError。</p>
<h3 id="JAVA堆"><a href="#JAVA堆" class="headerlink" title="JAVA堆"></a>JAVA堆</h3><p>&emsp;&emsp;JAVA堆是垃圾收集器主要管理的区域。其又可以细分为：新生代、老年代；或者Eden区、Frow survivor、To Survivor空间等。在内存分配的角度去看，线程共享的java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。无论如何分配器存储的都是对象实例。<br>&emsp;&emsp;一般的，根据Java虚拟机规范规定，堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的（通过-Xmx、-Xms来控制），目前主流的虚拟机都是可扩展的。如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出OutOfMemoryError:Java heap space异常。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>&emsp;&emsp;方法区也是线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。<br>&emsp;&emsp;方法区在物理上也不需要是连续的，可以选择固定大小或可扩展大小，并且方法区比堆还多了一个限制：可以选择是否执行垃圾收集。一般的，方法区上 执行的垃圾收集是很少的，这也是方法区被称为永久代的原因之一（HotSpot），但这也不代表着在方法区上完全没有垃圾收集，其上的垃圾收集主要是针对常量池的内存回收和对已加载类的卸载。如果对此区域未完全进行垃圾回收同样会导致内存泄漏。在方法区上定义了OutOfMemoryError:PermGen space异常，在内存不足时抛出。一般通过-XX:MaxPermSize设立方法区的内存大小</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>&emsp;&emsp;运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外（具体可参考第6章），还包含一项信息就是常量池，用于存放各种编译期生成的各种字面量和符号引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）。<br>&emsp;&emsp;但注意的是运行时常量池相对于Class文件的常量池的另一个特征是具有动态性。运行时常量池除了存储编译期常量外，也可以存储在运行时间产生的常量（比如String类的intern()方法，作用是String维护了一个常量池，如果调用的字符“abc”已经在常量池中，则返回池中的字符串地址，否则，新建一个常量加入池中，并返回地址）。参考如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">    String a =  <span class="string">"b"</span> ;   </div><div class="line">    String b =  <span class="string">"b"</span> ;   </div><div class="line">    System.out.print( a == b); <span class="comment">//1  </span></div><div class="line">    String c = <span class="string">"d"</span> ;  </div><div class="line">    String d = <span class="keyword">new</span> String( <span class="string">"d"</span> ).intern() ;   </div><div class="line">    System.out.println( c == d); <span class="comment">//2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码运行的结果均是true，但是1的原因是的编译期的时候，就已经将b这个常量放在了Class文件的常量池中，故a与b其实指向都是常量池中”b”的地址。而2之所以输出true则是运用了运行时常量池。一旦你调用了String类的intern方法其会先看当前的常量池中是否包含该常量，如果包含则指向同一个常量池中的位置，如果不包含则将该字符串对象放入常量池中。<br>同样运行时常量池在无法申请到内存时也会抛出OutOfMemoryError异常</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>&emsp;&emsp;直接内存并不是JVM管理的内存，可以这样理解，直接内存，就是 JVM以外的机器内存，比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存，JDK1.4中新加入了NIO（new input/output）类，引入了一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，其可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。 由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2016/07/24/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[JAVA对象的创建和内存存储布局]]></title>
      <url>http://yoursite.com/2016/07/29/JAVA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<h3 id="JAVA对象的创建"><a href="#JAVA对象的创建" class="headerlink" title="JAVA对象的创建"></a>JAVA对象的创建</h3><p>&emsp;&emsp;对象的创建一共分三步进行。</p>
<h4 id="1-、为对象分配内存"><a href="#1-、为对象分配内存" class="headerlink" title="(1)、为对象分配内存"></a>(1)、为对象分配内存</h4><p>&emsp;&emsp;这里所得创建对象（仅限于普通对象，不包含数组和Class对象等），通常我们通过一个new关键字创建对象。但我们要知道虚拟机在遇到一条new指令时，其首先将去检查这个指令参数（类名）是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载（将符号引用转变成直接引用，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）、解析和初始化过。如果没有，那必须先执行相应的类加载过程。<br>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。一个对象所需内存的大小在类加载完成后便可完全确定，而一般对象分配内存的方式有两种：</p>
<ol>
<li>指针碰撞：这是假设堆中内存总是工整的，所有使用过的内存放在一般、未使用的放在另一边，这样用一个指针作为分界点的指示器，那分配内存的时候就只需要该指针移动相应对象大小的距离就可以了。（这有点类似于JAVA内存回收中的标记-清除-整理算法后的内存状态）</li>
<li>空闲列表：但如果JAVA堆并不是规整的时候，就无法采用上述的方式，此时虚拟机就需要维护一个列表，记录哪些内存块是可用的，而在分配的时候在列表中寻找到一块足够大的空间划分给该对象实例，并且更新该列表上的记录，这种方式被称为“空闲列表”。（CMS垃圾收集器由于采用标记-清除的算法就容易导致内存碎片化，此时只能采用该方式为对象分配内存）。<br>&emsp;&emsp;所以说采用什么样的对象内存分配方式，本质上和该块内存使用什么样的垃圾收集器是密切相关的。<br>&emsp;&emsp;在内存分配中还需要考虑的一个问题如何保证内存分配的线程安全，即你可能出现正在给对象A分配内存，指针还未来得及修改，，对象B又同时使用了原来的指针分配内存的情况。解决这种并发问题（由于创建对象在jvm中是很频繁的问题）有两种方案：</li>
<li>一种是对分配内存空间的动作进行同步处理-实际上虚拟机采用CAS配上失败重试的方式保证指针更新操作的原子性</li>
<li>另一种是将内存分配的动作按照线程划分在不同的空间中进行，即为每个线程在JAVA堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB）。哪个线程需要分配堆内存，就在对象的那个线程的TLAB上分配，只有TLAB用完分配新的TLAB得时候才需要用到同步锁定。虚拟机是否使用TLAB通过-XX:+/-UseTLAB参数设定。<br>&emsp;&emsp;内存分配完成后，虚拟机需要为分配到内存空间初始化为零值（这里是指的是一些实例数据）。</li>
</ol>
<h4 id="2-、虚拟机对对象进行必要的设置-对象头的设置"><a href="#2-、虚拟机对对象进行必要的设置-对象头的设置" class="headerlink" title="(2)、虚拟机对对象进行必要的设置-对象头的设置"></a>(2)、虚拟机对对象进行必要的设置-对象头的设置</h4><p>&emsp;&emsp;虚拟机接下来会对该对象进行必要的设置，如该对象是哪个类的实例、如何找到类的元数据信息、对象的HASH码、对象的GC分代年龄等。这些信息都放在对象的对象头中。根据虚拟机当前的运行状态的不同，对象头会有不同的设置。</p>
<h4 id="3-、对象的初始化"><a href="#3-、对象的初始化" class="headerlink" title="(3)、对象的初始化"></a>(3)、对象的初始化</h4><p>&emsp;&emsp;对虚拟机而言，一个新的对象已经产生了，但对JAVA线程而言，对象的创建才刚刚开始，这是因为对象的初始化方法还没有执行（初始化代码块、构造函数等），此时所有的字段均为0，所以new指令之后会接着执行init方法，实现对对象的初始化。</p>
<h3 id="对象在内存中存储方式-内存中的存储布局"><a href="#对象在内存中存储方式-内存中的存储布局" class="headerlink" title="对象在内存中存储方式-内存中的存储布局"></a>对象在内存中存储方式-内存中的存储布局</h3><p>&emsp;&emsp;这一节主要说明一个对象在内存中是由哪几部分组成。一个对象在内存中存储布局可以分为三个区域：对象头、实例数据、对齐填充。<br>&emsp;&emsp;所谓对齐补充的存在不是必然的，也没有特殊的含义，仅仅起着占位符的作用，这是因为Hotspot的VM的自动内存管理系统要求对象的其实地址必须是8字节的整数倍，也即是说独享的大小必须是8字节的整数倍。而对象头正好是8字节的整数倍，而如果对象实例部分没有对齐的时候，就需要通过对齐填充来补全。</p>
<h3 id="对象的访问方式"><a href="#对象的访问方式" class="headerlink" title="对象的访问方式"></a>对象的访问方式</h3><p>&emsp;&emsp;一般来说，我们是通过reference数据来操作堆上的具体对象，但并没有定义这个引用通过何种方式去定位、方位堆中对象的具体位置，所以对象的访问方式也是取决于虚拟机的实现而定的。<br>一个Java的引用访问涉及到3个内存区域：JVM栈，堆，方法区。以最简单的本地变量引用：Object obj = new Object()为例：</p>
<ul>
<li>Object obj表示一个本地引用，存储在JVM栈的本地变量表中，表示一个reference类型数据；</li>
<li>new Object()作为实例对象数据存储在堆中；</li>
<li>堆中还记录了Object类的类型信息（接口、方法、field、对象类型等）的地址，这些地址所执行的数据存储在方法区中；</li>
</ul>
<p>&emsp;&emsp;目前主流的对象访问方式有两种：</p>
<ul>
<li>通过句柄访问：JAVA堆中会划分出一块内存来作为句柄池，reference中存放的是对象句柄的地址，而句柄中则包含了对象实例数据和类型数据的各自的具体地址信息。如图所示：<br><img src="../images/interview_method1.png" width="350" height="250" alt="图片名称" align="center"></li>
<li>使用直接指针访问：采用该方式JAVA堆对象就需要考虑如何放置访问类型数据的相关信息如图所示：<br><img src="../images/interview_method2.png" width="350" height="250" alt="图片名称" align="center"></li>
</ul>
<p>&emsp;&emsp;使用句柄池的好处是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集的时候移动对象）时只会改变句柄中的实例数据指针，而reference本身无需改变。使用直接指针的函数就是速度更快，节省了一次指针定位的开销，由于对象的访问在JAVA中非常频繁，所以这种开销还是很可观的。在hotspot vm中使用的是方法2。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JAVA内存区域与内存溢出异常]]></title>
      <url>http://yoursite.com/2016/07/26/JAVA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
      <content type="html"><![CDATA[<h2 id="JAVA内存区域-JAVA虚拟机运行时数据区"><a href="#JAVA内存区域-JAVA虚拟机运行时数据区" class="headerlink" title="JAVA内存区域-JAVA虚拟机运行时数据区"></a>JAVA内存区域-JAVA虚拟机运行时数据区</h2><p>&emsp;&emsp;了解Java GC机制，必须先清楚在JVM中内存区域的划分。在Java运行时的数据区里，由JVM管理的内存区域分为下图几个模块：<br><img src="xhwhutbupt.github.io/images/store.jpg" width="350" height="250" alt="图片名称" align="center"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>&emsp;&emsp;其实线程私有的，用于指定当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取吓一跳需要执行的字节码指令。如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，这是计数值则为空。该内存区域时唯一一个java虚拟机规范中没有规定outofmemoryerror的区域</p>
<h3 id="JAVA虚拟机栈"><a href="#JAVA虚拟机栈" class="headerlink" title="JAVA虚拟机栈"></a>JAVA虚拟机栈</h3><p>&emsp;&emsp;该区域同样是线程私有的，其生命周期和线程相同。一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。<br>&emsp;&emsp;局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。在局部变量表中，只有long和double类型会占 用2个局部变量空间（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。需要注意的是，局部变量表是在编译时就已经确定 好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。<br>&emsp;&emsp;虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StatckOverFlowError（栈溢出）；不过多 数Java虚拟机都允许动态扩展虚拟机栈的大小(有少部分是固定长度的)，所以线程可以一直申请栈，知道内存不足，此时，会抛出OutOfMemoryError（内存溢出）。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>&emsp;&emsp;本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同，唯一的区别是：虚拟机栈是执行Java方法的，而本地方法栈是用来执行native方法的，在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将本地方法栈与虚拟机栈放在一起使用。同样其会抛出两种异常分别是StatckOverFlowError和OutOfMemoryError。</p>
<h3 id="JAVA堆"><a href="#JAVA堆" class="headerlink" title="JAVA堆"></a>JAVA堆</h3><p>&emsp;&emsp;JAVA堆是垃圾收集器主要管理的区域。其又可以细分为：新生代、老年代；或者Eden区、Frow survivor、To Survivor空间等。在内存分配的角度去看，线程共享的java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。无论如何分配器存储的都是对象实例。<br>&emsp;&emsp;一般的，根据Java虚拟机规范规定，堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的（通过-Xmx、-Xms来控制），目前主流的虚拟机都是可扩展的。如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出OutOfMemoryError:Java heap space异常。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>&emsp;&emsp;方法区也是线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。<br>&emsp;&emsp;方法区在物理上也不需要是连续的，可以选择固定大小或可扩展大小，并且方法区比堆还多了一个限制：可以选择是否执行垃圾收集。一般的，方法区上 执行的垃圾收集是很少的，这也是方法区被称为永久代的原因之一（HotSpot），但这也不代表着在方法区上完全没有垃圾收集，其上的垃圾收集主要是针对常量池的内存回收和对已加载类的卸载。如果对此区域未完全进行垃圾回收同样会导致内存泄漏。在方法区上定义了OutOfMemoryError:PermGen space异常，在内存不足时抛出。一般通过-XX:MaxPermSize设立方法区的内存大小</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>&emsp;&emsp;运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外（具体可参考第6章），还包含一项信息就是常量池，用于存放各种编译期生成的各种字面量和符号引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）。<br>&emsp;&emsp;但注意的是运行时常量池相对于Class文件的常量池的另一个特征是具有动态性。运行时常量池除了存储编译期常量外，也可以存储在运行时间产生的常量（比如String类的intern()方法，作用是String维护了一个常量池，如果调用的字符“abc”已经在常量池中，则返回池中的字符串地址，否则，新建一个常量加入池中，并返回地址）。参考如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">    String a =  <span class="string">"b"</span> ;   </div><div class="line">    String b =  <span class="string">"b"</span> ;   </div><div class="line">    System.out.print( a == b); <span class="comment">//1  </span></div><div class="line">    String c = <span class="string">"d"</span> ;  </div><div class="line">    String d = <span class="keyword">new</span> String( <span class="string">"d"</span> ).intern() ;   </div><div class="line">    System.out.println( c == d); <span class="comment">//2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码运行的结果均是true，但是1的原因是的编译期的时候，就已经将b这个常量放在了Class文件的常量池中，故a与b其实指向都是常量池中”b”的地址。而2之所以输出true则是运用了运行时常量池。一旦你调用了String类的intern方法其会先看当前的常量池中是否包含该常量，如果包含则指向同一个常量池中的位置，如果不包含则将该字符串对象放入常量池中。<br>同样运行时常量池在无法申请到内存时也会抛出OutOfMemoryError异常</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>&emsp;&emsp;直接内存并不是JVM管理的内存，可以这样理解，直接内存，就是 JVM以外的机器内存，比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存，JDK1.4中新加入了NIO（new input/output）类，引入了一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，其可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。 由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2016/07/24/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
